# -*- coding: utf-8 -*-
"""PREDICCION.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xd0bce8huRjumRkU2Ygx5BY0ciNi28m3

#### Install yfinance
"""



"""# Forecasting Stocks from Yahoo Finance with Prophet"""

from pandas import Series, DataFrame

import pandas_datareader.data as pdr
import datetime
import yfinance as yf


# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
from matplotlib import style
# Adjusting the size of matplotlib
import matplotlib as mpl


from pandas.plotting import scatter_matrix

import math
import numpy as np
from sklearn import preprocessing

from sklearn.linear_model import LinearRegression
from sklearn.neighbors import KNeighborsRegressor

from sklearn.linear_model import Ridge
from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import make_pipeline
import seaborn as sns

from sklearn.metrics import mean_squared_error, r2_score

import seaborn as sns; sns.set_theme(color_codes=True)

import json 
from django.http import HttpResponse

def ggplot(request):

    empresa=request.GET["empresa"]
    yf.pdr_override() 
    ahora = datetime.datetime.utcnow()
    start = ahora - datetime.timedelta(days=1800)
    end = ahora - datetime.timedelta(days=1)
    df = pdr.get_data_yahoo(empresa, start, end)
    df.tail()


    close_px = df['Adj Close']
    mavg = close_px.rolling(window=100).mean()


    mpl.rc('figure', figsize=(30, 7) )
    mpl.__version__

    style.use('ggplot')
    close_px.plot(label=empresa)
    mavg.plot(label='mavg')

    plt.legend()

    rets = close_px / close_px.shift(1) - 1
    rets.plot(label='return')

    dfcomp = pdr.DataReader(['BBY', 'MELI', 'AMZN', 'EBAY'],start,end)['Adj Close']

    dfcomp

    retscomp = dfcomp.pct_change()
    corr = retscomp.corr()
    corr



    #scatter_matrix(retscomp, diagonal='kde', figsize=(10, 10))

    plt.scatter(retscomp.mean(), retscomp.std())
    plt.xlabel('Retorno esperado')
    plt.ylabel('Riesgo')
    for label, x, y in zip(retscomp.columns, retscomp.mean(), retscomp.std()):
        plt.annotate(label,xy = (x, y), xytext = (20, -20),
        textcoords = 'offset points', ha = 'right', va = 'bottom',
        bbox = dict(boxstyle = 'round,pad=0.5', fc = 'yellow', alpha = 0.5),
        arrowprops = dict(arrowstyle = '->', connectionstyle = 'arc3,rad=0'))

    dfreg = df.loc[:,['Adj Close','Volume']]
    dfreg['HL_PCT'] = (df['High'] - df['Low']) / df['Close'] * 100.0
    dfreg['PCT_change'] = (df['Close'] - df['Open']) / df['Open'] * 100.0
    dfreg


    # Eliminar el valores faltantes
    dfreg.fillna(value=-99999, inplace=True)
    dfreg.isnull().sum()

    # Queremos separar el 1 por ciento de los datos para pronosticar
    forecast_out = int(math.ceil(0.20 * len(dfreg)))
    forecast_out

    # Separando la etiqueta aquí, queremos predecir el AdjClose
    forecast_col = 'Adj Close'
    dfreg['label'] = dfreg[forecast_col].shift(-forecast_out)
    dfreg

    # Escala la X para que todos puedan tener la misma distribución para la regresión lineal
    X = np.array(dfreg.drop(['label'], 1))
    X = preprocessing.scale(X)
    X

    # Por último, queremos encontrar las series de datos de X tardía y X temprana (entreno) para la generación y evaluación del modelo
    #ultimos 135
    X_lately = X[-forecast_out:]
    X_lately.size

    X = X[:-forecast_out]
    X.size

    # Separar la etiqueta e identificarla como y
    y = np.array(dfreg['label'])
    y = y[:-forecast_out]

    xtrain=dfreg.iloc[0:(round(len(dfreg)*0.8)),0]
    ytrain=dfreg.iloc[0:(round(len(dfreg)*0.8)),1]
    xtest=dfreg.iloc[(round(len(dfreg)*0.8)):,0]
    ytest=dfreg.iloc[(round(len(dfreg)*0.8)):,1]


    # Creamos el objeto de Regresión Linear
    regr = LinearRegression(n_jobs=-1)
    
    # Entrenamos nuestro modelo
    regr.fit(X, y)
    
    # Hacemos las predicciones que en definitiva una línea (en este caso, al ser 2D)
    y_pred = regr.predict(X)
    
    # Veamos los coeficienetes obtenidos, En nuestro caso, serán la Tangente
    print('Coefficients: \n', regr.coef_)
    # Este es el valor donde corta el eje Y (en X=0)
    print('Independent term: \n', regr.intercept_)
    # Error Cuadrado Medio
    print("Mean squared error: %.2f" % mean_squared_error(y, y_pred))
    # Puntaje de Varianza. El mejor puntaje es un 1.0
    print('Variance score: %.2f' % r2_score(y, y_pred))


    tips = sns.load_dataset("tips")
    ax = sns.regplot(x="total_bill", y="tip", data=tips)

    forecast_set = regr.predict(X_lately)
    dfreg['Pronostico'] = np.nan
    dfreg

    last_date = dfreg.iloc[-1].name
    last_unix = last_date
    next_unix = last_unix + datetime.timedelta(days=1)
    for i in forecast_set:
        next_date = next_unix
        next_unix += datetime.timedelta(days=1)
        dfreg.loc[next_date] = [np.nan for _ in range(len(dfreg.columns)-1)]+[i]
    dfreg

    lista1=list()
    
    dfreg['Adj Close'].tail(1500)
    for i in dfreg.index:
        if not np.isnan( dfreg["Adj Close"][i] ) :
            lista1.append({"fecha":""+i.strftime("%m/%d/%Y"),"y":dfreg["Adj Close"][i]})
        


  

    dfreg['Pronostico'].tail(1500).plot( figsize=(15, 5))

    
    for i in dfreg.index:
        if not np.isnan( dfreg["Pronostico"][i] ) :
            lista1.append({"fecha":""+i.strftime("%m/%d/%Y"),"y":dfreg["Pronostico"][i]})
        
    dump = json.dumps(lista1)
    return HttpResponse(dump, content_type='application/json')

